\chapter{Interacción con el usuario}

\section{Contenidos en parte 3}
\begin{itemize}
    \item Respuesta a cambios en la selección dentro de la tabla.
    \item Añade funcionalidad de los botones añadir, editar, y borrar.
    \item Crear un diálogo emergente (popup dialog) a medida para editar un contacto.
    \item Validación de la entrada del usuario.
\end{itemize}

\section{Respuesta a cambios en la selección de la Tabla}
Todavía no hemos usado la parte derecha de la interfaz de nuestra aplicación. 
La intención es usar esta parte para mostrar los detalles de la persona seleccionada por 
el usuario en la tabla. \\
En primer lugar vamos a añadir un nuevo método dentro de \codigo{PersonOverviewController} que nos ayude a 
rellenar las etiquetas con los datos de una sola persona. \\

Crea un método llamado \codigo{showPersonaDetails(Persona persona)}. Este método recorrerá todas las etiquetas y 
establecerá el texto con detalles de la persona usando \codigo{setText(...)}. Si en vez de una instancia de 
\codigo{Person} se pasa null entonces las etiquetas deben ser borradas. \\

\codigo{PersonOverviewController.java} nuevo método \codigo{showPersonaDetails(Persona persona)}
\begin{minted}[
    linenos,
    numbersep=5pt,
    gobble=0,
    frame=lines,
    framesep=2mm,
    breaklines=true,
    ]{java}

    /**
    * Rellena todos los campos de texto para mostrar detalles sobre la persona.
    * Si la persona especificada es nula, se borran todos los campos de texto.
    * @param persona
    */
   private void showPersonaDetails(Persona persona){
       if(persona != null){
           //Rellene las etiquetas con información del objeto persona.
           nombreLabel.setText(persona.getNombre().get());
           apelidoLabel.setText(persona.getApellido().get());
           calleLabel.setText(persona.getCalle().get());
           codigoPostaLabel.setText(persona.getCodigoPostal().get() + "");
           ciudadLabel.setText(persona.getCiudad().get());
           //¡Necesitamos una forma de convertir el cumpleaños en una Cadena!
           onomasticoLabel.setText(...);
           // onomasticoLabel.setText(DateUtil.format(persona.getOnomastico().get()));
       }else {
           //Si la persona es nula, quitar todo el texto
           nombreLabel.setText("");
           apelidoLabel.setText("");
           calleLabel.setText("");
           codigoPostaLabel.setText("");
           ciudadLabel.setText("");
           onomasticoLabel.setText("");
       }
   }
\end{minted}

\section{Convierte la fecha de nacimiento en una cadena}
Te darás cuenta de que no podemos usar el atributo \codigo{onomastico} directamente 
para establecer el valor de una \codigo{Label} porque se requiere un \codigo{String}, y \codigo{onomastico} es de 
tipo \codigo{LocalDate}. Así pues necesitamos convertir \codigo{onomastico} de \codigo{LocalDate} a \codigo{String}.\\

En la práctica vamos a necesitar convertir entre \codigo{LocalDate} y \codigo{String} en varios sitios y en ambos 
sentidos. Una buena práctica es crear una clase auxiliar con métodos estáticos (\codigo{static}) para esta finalidad. 
Llamaremos a esta clase \codigo{DateUtil} y la ubicaremos una paquete separado denominado \codigo{ch.makery.direcciones.util}:\\

\codigo{DateUtil.java}
\begin{minted}[
    linenos,
    numbersep=5pt,
    gobble=0,
    frame=lines,
    framesep=2mm,
    breaklines=true,
    ]{java}

    package ch.makery.direcciones.util;

    import java.time.LocalDate;
    import java.time.format.DateTimeFormatter;
    
    /**
     * Funciones de ayuda para manejar fechas.
     * @author Marco Jakob
     *
     */
    public class DateUtil {
        /**
         * El patrón de fecha que se utiliza para la conversión.
         * Cambialo como quieras.
         */
        private static final String DATE_PATTERN = "dd-MM-yyyy";
        /**
         * Formateado de fecha
         */
        private static final DateTimeFormatter DATE_FORMATTER =
                DateTimeFormatter.ofPattern(DATE_PATTERN);
        /**
         * Devuelve la fecha que se pasó como parametro en una cadena
         * @param date fecha en formato LocalDate
         * @return fecha en un String
         */
        public static String format(LocalDate date){
            if(date == null){
                return null;
            }
            return DATE_FORMATTER.format(date);
        }
        /**
         * Convierte una cadena en formato de fecha a un objeto LocalDate
         * Retorna nulo si la cadena no pudo convertirse
         *
         * @param dateString fecha como un String
         * @return un objeto de tipo fecha, si no se pudo convertir retorna nulo
         */
        public static LocalDate parse(String dateString){
            try {
                return DATE_FORMATTER.parse(dateString, LocalDate::from);
            } catch (Exception e) {
                return null;
            }
        }
        /**
         * Comprueba la cadena si es una fecha valida
         * @param dateString
         * @return verdadero si la cadena es una fecha valida.
         */
        public static boolean validDate(String dateString){
            //Intenta analizar la cadena
            return DateUtil.parse(dateString) != null;
        }
    }

\end{minted}

\subsection{Utilización de la clase DateUtil}
Ahora necesitamos utilizar la nueva clase \codigo{DateUtil} en el método \codigo{showPersonDetails} de 
\codigo{PersonaOverviewController}. Sustituye el TODO que habíamos añadido con la línea siguiente:

\begin{minted}[
    linenos,
    numbersep=5pt,
    gobble=0,
    frame=lines,
    framesep=2mm,
    breaklines=true,
    ]{java}
    onomasticoLabel.setText(DateUtil.format(persona.getOnomastico().get()));
\end{minted}

\section{Detecta cambios de selección en la tabla}
Para enterarse de que el usuario ha seleccionado a un persona en la tabla de contactos, 
necesitamos escuchar los cambios. Esto se consigue mediante la implementación de un interface de JavaFX 
que se llama \codigo{ChangeListener} con un método llamado \codigo{changed(...)}. Este método solo tiene tres 
parámetros: \codigo{observable}, \codigo{oldValue}, y \codigo{newValue}. \\
En Java 8 la forma más elegante de implementar una interfaz con un único método es mediante una \textit{lambda expression}. 
Añadiremos algunas líneas al método \codigo{initialize()} de \codigo{PersonaOverviewController}. 
El código resultante se asemejará al siguiente:\\
\codigo{PersonOverviewController.java}

\begin{minted}[
    linenos,
    numbersep=5pt,
    gobble=0,
    frame=lines,
    framesep=2mm,
    breaklines=true,
    ]{java}
    /**
	 * Inicializa la clase de controlador
	 * Este método se llama automáticamente después de cargar el archivo fxml.
	 */
	@FXML
	private void initialize(){
		//Inicialice la tabla de personas con las dos columnas.
		nombresColumna.setCellValueFactory(cellData -> cellData.getValue().getNombre());
		apellidosColumna.setCellValueFactory(cellData -> cellData.getValue().getApellido());

		//Limpiar detalles de persona
		showPersonaDetails(null);

		//Escuche los cambios de selección y muestre los detalles de la persona cuando cambie.
		personTable.getSelectionModel().selectedItemProperty().addListener(
				(observable, oldValue, newValue) -> showPersonaDetails(newValue));
	}
\end{minted}

Con \codigo{showPersonDetails(null);} borramos los detalles de una persona.\\
Con \codigo{personaTable.getSelectionModel...} obtenemos la \textit{selectedItemProperty} de la tabla de personas, 
y le añadimos un \textit{listener}. Cuando quiera que el usuario seleccione a una persona en la tabla, 
nuestra \textit{lambda expression} será ejecutada: se toma la persona recien seleccionada y se le pasa al 
método \codigo{showPersonDetails(...)}. \\
Intenta \textbf{ejecutar tu aplicación} en este momento. Comprueba que cuando seleccionas a una persona, 
los detalles sobre esta son mostrados en la parte derecha de la ventana. \\
Si algo no funciona, puedes comparar tu clase \codigo{PersonaOverviewController} con 
\textcolor{azul}{\href{https://github.com/mateomtz199/direccionesapp-part4}{PersonOverviewController.java}}.

\section{El botón de borrar (Delete)}
Nuestro interfaz de usuario ya contiene un botón de borrar, pero sin funcionalidad. Podemos seleccionar la 
acción a ejecutar al pulsar un botón desde el \textit{Scene Builder}. Cualquier método de nuestro controlador 
anotado con \codigo{ @FXML} (o declarado como \textit{public}) es accesible desde \textit{Scene Builder}. 
Así pues, empecemos añadiendo el método de borrado al final de nuestra clase \codigo{PersonaOverviewController}:\\
\codigo{PersonaOverviewController.java}

\begin{minted}[
    linenos,
    numbersep=5pt,
    gobble=0,
    frame=lines,
    framesep=2mm,
    breaklines=true,
    ]{java}
    /**
	 * Se llama cuando el usuario hace clic en el botón Eliminar.
	 */
	@FXML
	private void handleDeletePersona(){
		int selectedIndex = personTable.getSelectionModel().getSelectedIndex();
		if(selectedIndex >= 0){
			personTable.getItems().remove(selectedIndex);
		}
		else {
			Alert alert = new Alert(AlertType.WARNING);
			alert.setTitle("Sin seleccion");
			alert.setHeaderText("No has seleccionado una persona");
			alert.setContentText("Por favor selecciona una persona de la lista para eliminar");
			alert.showAndWait();
		}
	}
\end{minted}

